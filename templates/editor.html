{% extends "layout.html" %}

{% block extra_styles %}
/* EDITOR PAGE SPECIFIC STYLES */

/* === PAGE LAYOUT OPTIMIZATION === */
html, body {
    height: 100vh;
    overflow-x: hidden;
    margin: 0;
    padding: 0;
}

body {
    font-size: 16px;
    display: flex;
    flex-direction: column;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* === AUTO-SAVE ICON STYLES === */
.auto-save-indicator {
    display: inline-flex;
    align-items: center;
    margin-left: 10px;
    font-size: 0.8rem;
    color: #16a34a;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.auto-save-indicator.show {
    opacity: 1;
}

.auto-save-indicator i {
    margin-right: 4px;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* === TOOLBAR STYLING (Header with Buttons) === */
.d-flex.justify-content-between.align-items-center.mb-4 {
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(10px);
}

/* === BUTTON GROUP STYLING === */
.btn-group {
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    overflow: hidden;
}

.btn-group .btn {
    font-weight: 500;
    padding: 0.6rem 1.2rem;
    font-size: 0.9rem;
    border: none;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.btn-group .btn-outline-secondary {
    border: 1px solid #6b7280;
    color: #6b7280;
    background: #ffffff;
}

.btn-group .btn-outline-secondary:hover {
    background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
    border-color: #4b5563;
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(107, 114, 128, 0.3);
}

.btn-group .btn-primary {
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    color: white;
}

.btn-group .btn-primary:hover {
    background: linear-gradient(135deg, #1d4ed8 0%, #1e3a8a 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

/* === FORM CONTAINER STYLING === */
#editorForm {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

/* === TITLE INPUT STYLING === */

.mb-3:first-of-type .form-label {
    color: #374151;
    font-weight: 600;
    font-size: 1rem;
    margin-bottom: 0.5rem;
}

.mb-3:first-of-type .form-control {
    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    color: #1e293b;
    transition: all 0.3s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.mb-3:first-of-type .form-control:focus {
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    outline: none;
    background: #ffffff;
}

/* === MAIN CONTENT ROW === */
.row.mb-3 {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    margin: 0;
}

.row.mb-3 .col-12 {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    padding: 0;
}

/* === CHECKBOX STYLING === */
.form-check {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0;
}

.form-check-input {
    width: 18px;
    height: 18px;
    margin-top: 0;
    accent-color: #3b82f6;
    cursor: pointer;
    transition: all 0.2s ease;
}

.form-check-input:focus {
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15);
    outline: none;
}

.form-check-label {
    font-size: 0.9rem;
    font-weight: 500;
    color: #374151;
    cursor: pointer;
    margin-bottom: 0;
    user-select: none;
}

/* === SELECT DROPDOWN STYLING === */
.d-flex.align-items-center.gap-2 {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.d-flex.align-items-center.gap-2 .form-label {
    font-size: 0.9rem;
    font-weight: 500;
    color: #374151;
    margin-bottom: 0;
    white-space: nowrap;
}

.form-select.form-select-sm {
    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
    border: 1px solid #d1d5db;
    border-radius: 6px;
    padding: 0.4rem 0.75rem;
    font-size: 0.85rem;
    color: #374151;
    transition: all 0.3s ease;
    width: 200px;
    cursor: pointer;
}

.form-select.form-select-sm:focus {
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
    outline: none;
    background: #ffffff;
}

/* === MAIN TEXTAREA STYLING === */
#editorContent {
    flex: 1;
    min-height: 400px;
    background: linear-gradient(135deg, #ffffff 0%, #fafbfc 100%);
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    padding: 1.5rem;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.6;
    color: #1e293b;
    resize: none;
    transition: all 0.3s ease;
    box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.05),
        0 1px 3px rgba(0, 0, 0, 0.02);
    white-space: pre-wrap;
    word-wrap: break-word;
}

#editorContent:focus {
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    outline: none;
    background: #ffffff;
}

#editorContent::placeholder {
    color: #9ca3af;
    font-style: italic;
}

/* === SCROLLBAR STYLING === */
#editorContent::-webkit-scrollbar {
    width: 8px;
}

#editorContent::-webkit-scrollbar-track {
    background: #f8fafc;
    border-radius: 4px;
}

#editorContent::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #cbd5e1 0%, #94a3b8 100%);
    border-radius: 4px;
    border: 1px solid #f8fafc;
}

#editorContent::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
}

/* === BUTTON HOVER EFFECTS === */
.btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.btn:hover::before {
    left: 100%;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

.btn:disabled::before {
    display: none;
}

/* === ANIMATIONS === */
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* === FOCUS ENHANCEMENT === */
.form-control:focus,
.form-select:focus,
.form-check-input:focus {
    outline: 2px solid transparent;
    outline-offset: 2px;
}

/* === FORM VALIDATION STATES === */
.form-control.is-valid {
    border-color: #16a34a;
    box-shadow: 0 0 0 2px rgba(22, 163, 74, 0.1);
}

.form-control.is-invalid {
    border-color: #dc2626;
    box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.1);
}

/* === UTILITY STYLES === */
.text-danger {
    color: #dc2626 !important;
    font-weight: 500;
}

.text-success {
    color: #16a34a !important;
    font-weight: 500;
}

/* === RESPONSIVE DESIGN === */
@media (max-width: 768px) {
    .d-flex.justify-content-between.align-items-center.mb-4 {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
        padding: 1rem 1.5rem;
    }
    
    .btn-group {
        width: 100%;
    }
    
    .btn-group .btn {
        flex: 1;
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
    }
    
    .d-flex.align-items-center.gap-3.mb-2 {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem !important;
        padding: 1rem;
    }
    
    .d-flex.align-items-center.gap-2 {
        width: 100%;
        justify-content: space-between;
    }
    
    .form-select.form-select-sm {
        width: 100%;
        max-width: 200px;
    }
    
    #editorContent {
        min-height: 300px;
        padding: 1rem;
        font-size: 13px;
    }
    
    .mb-3:first-of-type .form-control {
        font-size: 0.95rem;
        padding: 0.65rem 0.85rem;
    }

    .auto-save-indicator {
        margin-left: 5px;
        font-size: 0.75rem;
    }
}

@media (max-width: 576px) {
    .d-flex.justify-content-between.align-items-center.mb-4 {
        padding: 0.75rem 1rem;
    }
    
    .btn-group .btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
    }
    
    .d-flex.align-items-center.gap-3.mb-2 {
        padding: 0.75rem;
    }
    
    .form-check-label,
    .d-flex.align-items-center.gap-2 .form-label {
        font-size: 0.85rem;
    }
    
    .form-select.form-select-sm {
        font-size: 0.8rem;
        padding: 0.35rem 0.6rem;
    }
    
    #editorContent {
        min-height: 250px;
        padding: 0.75rem;
        font-size: 12px;
    }
    
    .mb-3:first-of-type .form-control {
        font-size: 0.9rem;
        padding: 0.6rem 0.75rem;
    }
    
    .mb-3:first-of-type .form-label {
        font-size: 0.95rem;
    }
}

/* === ENHANCED VISUAL EFFECTS === */

#editorContent {
    box-shadow: 
        0 2px 4px rgba(0, 0, 0, 0.05),
        0 1px 8px rgba(0, 0, 0, 0.02);
}

.d-flex.align-items-center.gap-3.mb-2 {
    box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.04),
        0 1px 6px rgba(0, 0, 0, 0.02);
}

/* === TYPOGRAPHY ENHANCEMENTS === */
* {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.form-label {
    font-weight: 600;
    letter-spacing: 0.025em;
}

/* === ACCESSIBILITY IMPROVEMENTS === */
.btn:focus-visible {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
}

.form-control:focus-visible,
.form-select:focus-visible {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
}

/* === DARK MODE SUPPORT (if needed in future) === */
@media (prefers-color-scheme: dark) {
    /* Dark mode styles can be added here */
}

/* === PRINT STYLES === */
@media print {
    .d-flex.justify-content-between.align-items-center.mb-4 {
        display: none !important;
    }
    
    #editorContent {
        border: 1px solid #000;
        box-shadow: none;
        background: white !important;
    }
}

.d-flex.justify-content-between.align-items-center.mb-4 {
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(10px);
    gap: 1rem;
}

/* Controls styling for header */
.d-flex.justify-content-between.align-items-center.mb-4 .d-flex.align-items-center.gap-3 {
    background: none;
    border: none;
    padding: 0;
    margin-bottom: 0 !important;
    box-shadow: none;
    flex-wrap: wrap;
    gap: 1rem !important;
}
/* Enhanced responsive design */
@media (max-width: 992px) {
    .d-flex.justify-content-between.align-items-center.mb-4 {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
    }
    
    .d-flex.justify-content-between.align-items-center.mb-4 .d-flex.align-items-center.gap-3 {
        width: 100%;
        justify-content: flex-start;
        flex-wrap: wrap;
    }
}

@media (max-width: 768px) {
    .d-flex.justify-content-between.align-items-center.mb-4 {
        padding: 1rem;
    }
    
    .btn-group {
        width: 100%;
        margin-bottom: 0.5rem;
    }
    
    .d-flex.align-items-center.gap-3 {
        flex-direction: column;
        align-items: flex-start !important;
        gap: 0.75rem !important;
        width: 100%;
    }
    
    .d-flex.align-items-center.gap-2 {
        width: 100%;
        justify-content: space-between;
    }
    
    .form-select.form-select-sm {
        width: 150px !important;
    }
}

@media (max-width: 576px) {
    .d-flex.align-items-center.gap-3 label:first-child {
        font-size: 11px !important;
    }
    
    .form-check-label,
    .d-flex.align-items-center.gap-2 .form-label {
        font-size: 11px !important;
    }
    
    .form-select.form-select-sm {
        width: 120px !important;
        font-size: 0.75rem;
    }
    
    .auto-save-indicator {
        font-size: 0.7rem;
    }
}

/* Responsive cho mobile */
@media (max-width: 768px) {
    .col-12 {
        margin-bottom: 15px;
    }
}
#editorContent:disabled {
    background: #f1f5f9 !important;
    color: #b0b0b0 !important;
    cursor: not-allowed;
    opacity: 0.7;
}

{% endblock %}


{% block content %}
<div class="container-fluid">
    <!-- Header với buttons và controls cùng hàng -->
    <div class="d-flex justify-content-between align-items-center mb-4 flex-wrap">
        
        <!-- Controls moved to same row -->
        <div class="d-flex align-items-center gap-3">
            <label class="form-" style="font-size: 12px;"><strong>Auto save when the title is not blank!</strong></label>
            <div class="form-check">
                <input type="checkbox" id="enableNumbering" class="form-check-input" checked>
                <label for="enableNumbering" class="form-check-label" style="font-size: 12px;">Enable auto numbering</label>
            </div>
            <div class="d-flex align-items-center gap-2">
                <label for="tabSkipCount" class="form-label mb-0" style="font-size: 12px; white-space: nowrap;">Tab skip count:</label>
                <select id="tabSkipCount" class="form-select form-select-sm" style="width: 200px;">
                    <option value="0">0 (immediate numbering)</option>
                    <option value="1" selected>1 (skip first tab)</option>
                    <option value="2">2 (skip first 2 tabs)</option>
                    <option value="3">3 (skip first 3 tabs)</option>
                    <option value="4">4 (skip first 4 tabs)</option>
                    <option value="5">5 (skip first 5 tabs)</option>
                </select>
                <div class="auto-save-indicator" id="autoSaveIndicator">
                    <i class="bi bi-check-circle"></i>
                    <span>Auto-saved</span>
                </div>
            </div>
        </div>
    </div>
    
    <form id="editorForm">
        <div class="mb-3">
            <input type="text" class="form-control" id="title" name="title" 
                   value="{{ document.title if document else '' }}" required>
        </div>
        
        <!-- Content area simplified -->
        <div class="row mb-3">
            <div class="col-12">               
                <textarea class="form-control" id="editorContent" name="content" 
                rows="20" style="font-family: monospace; font-size: 14px;" required>{{ document.content if document else '' }}</textarea>
            </div>
        </div>
    </form>
</div>

<style>
#editorContent {
    line-height: 1.5;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* Responsive cho mobile */
@media (max-width: 768px) {
    .row .col-md-2, .row .col-md-8 {
        margin-bottom: 15px;
    }
    
    /* Trên mobile, Title và Settings stack vertically, Content full width */
    .col-md-2:first-child {
        order: 1;
    }
    .col-md-8 {
        order: 3;
    }
    .col-md-2:last-child {
        order: 2;
    }
}
@media (max-width: 768px) {
    /* Remove the old col-md-2, col-md-8 rules and replace with: */
    .col-12 {
        margin-bottom: 15px;
    }
}
</style>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const textarea = document.getElementById('editorContent');
    const form = document.getElementById('editorForm');
    const titleInput = document.getElementById('title');
    const autoSaveIndicator = document.getElementById('autoSaveIndicator');
    
    // Auto-save state
    let currentDocumentId = null;
    let lastSavedTitle = '';
    let lastSavedContent = '';
    let isAutoSaving = false;
    let autoSaveTimer = null;
    let contentChangeTimer = null;
    const autoSaveDelay = 2000;
    const autoSaveInterval = 5000; // Tăng interval lên 5 giây như memo.html
    
    // Editor state
    let currentLineIndent = 0;
    let lastLineIndex = -1;
    let currentTabCount = 0;
    
    // Undo/Redo functionality
    let undoStack = [];
    let redoStack = [];
    const maxUndoSteps = 50;
    let inputTimer = null;

    // ===== INITIALIZATION =====
    
    function initializeDocumentId() {
        const urlParams = new URLSearchParams(window.location.search);
        currentDocumentId = urlParams.get('id');
        console.log('Document ID initialized:', currentDocumentId);
        
        if (currentDocumentId) {
            lastSavedTitle = titleInput.value.trim();
            lastSavedContent = textarea.value.trim();
        }
    }

    function loadDocument(documentId) {
        console.log('Loading document:', documentId);
        
        fetch(`/api/editor_documents/${documentId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.document) {
                titleInput.value = data.document.title;
                textarea.value = data.document.content;
                
                currentDocumentId = documentId;
                lastSavedTitle = data.document.title;
                lastSavedContent = data.document.content;
                
                console.log('Document loaded successfully:', {
                    id: currentDocumentId,
                    title: data.document.title,
                    contentLength: data.document.content.length
                });
                
                // Initialize undo stack with loaded content
                saveInitialState();
            } else {
                console.error('Document load error:', data.error);
                alert('Error: ' + (data.error || 'Document not found'));
            }
        })
        .catch(error => {
            console.error('Document load error:', error);
            alert('Error loading document: ' + error.message);
        });
    }

    // ===== AUTO-SAVE FUNCTIONALITY (FIXED) =====
    
    // Auto-save functionality tương tự memo.html
    function initializeAutoSave() {
        const title = titleInput.value.trim();
        const content = textarea.value.trim();
        lastSavedTitle = title;
        lastSavedContent = content;
        startAutoSave();
    }

    function startAutoSave() {
        if (autoSaveTimer) {
            clearInterval(autoSaveTimer);
        }
        
        autoSaveTimer = setInterval(() => {
            const title = titleInput.value.trim();
            const content = textarea.value.trim();
            
            // Check conditions: title must not be blank and content must have changed
            if (title && 
                !isAutoSaving && 
                (title !== lastSavedTitle || content !== lastSavedContent)) {
                performAutoSave();
            }
        }, autoSaveInterval); // Auto-save every 5 seconds
    }

    // Enhanced auto-save function with promise support (like memo.html)
    function performAutoSave() {
        const title = titleInput.value.trim();
        const content = textarea.value.trim();
        
        if (!title) return Promise.resolve();
        
        // QUAN TRỌNG: Check if already saving
        if (isAutoSaving) {
            console.log('Auto-save skipped: Already saving');
            return Promise.resolve();
        }
        
        // QUAN TRỌNG: Check if no changes
        if (title === lastSavedTitle && content === lastSavedContent) {
            console.log('Auto-save skipped: No changes detected');
            return Promise.resolve();
        }
        
        isAutoSaving = true;
        
        const url = currentDocumentId ? `/api/editor_documents/${currentDocumentId}` : '/api/editor_documents';
        const method = currentDocumentId ? 'PUT' : 'POST';
        
        return fetch(url, {
            method: method,
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ title, content })
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                throw new Error(data.error);
            }
            
            // QUAN TRỌNG: Update saved values NGAY LẬP TỨC
            lastSavedTitle = title;
            lastSavedContent = content;
            showAutoSaveIndicator();
            
            // QUAN TRỌNG: Chỉ set document ID khi thực sự tạo mới
            if (!currentDocumentId && data.id) {
                currentDocumentId = data.id;
                // Update URL without reload
                window.history.replaceState({}, '', `/editor?id=${data.id}`);
                console.log(`New document created with ID: ${currentDocumentId}`);
            }
            
            return data;
        })
        .catch(error => {
            console.error('Auto-save error:', error);
            throw error;
        })
        .finally(() => {
            isAutoSaving = false;
        });
    }

    // === NEW: Focus out auto-save functionality (from memo.html) ===
    
    function performAutoSaveOnFocusOut(synchronous = false) {
        const title = titleInput.value.trim();
        const content = textarea.value.trim();
        
        // Only save if title is not blank and content has changed
        if (!title || isAutoSaving) return Promise.resolve();
        
        if (title === lastSavedTitle && content === lastSavedContent) {
            return Promise.resolve(); // No changes to save
        }
        
        if (synchronous) {
            // For beforeunload and navigation events, use synchronous save
            return performSynchronousAutoSave(title, content);
        } else {
            // For focus events, use regular async save
            return performAutoSave();
        }
    }

    // Synchronous save for critical navigation events (from memo.html)
    function performSynchronousAutoSave(title, content) {
        if (!title || !currentDocumentId) return Promise.resolve();
        
        const url = `/api/editor_documents/${currentDocumentId}`;
        
        // Use sendBeacon for reliable sending during page unload
        if (navigator.sendBeacon) {
            const data = JSON.stringify({ title, content });
            const blob = new Blob([data], { type: 'application/json' });
            navigator.sendBeacon(url, blob);
            
            // Update local state
            lastSavedTitle = title;
            lastSavedContent = content;
            return Promise.resolve();
        } else {
            // Fallback to synchronous XHR
            return new Promise((resolve) => {
                const xhr = new XMLHttpRequest();
                xhr.open('PUT', url, false); // synchronous
                xhr.setRequestHeader('Content-Type', 'application/json');
                
                try {
                    xhr.send(JSON.stringify({ title, content }));
                    if (xhr.status >= 200 && xhr.status < 300) {
                        lastSavedTitle = title;
                        lastSavedContent = content;
                    }
                } catch (error) {
                    console.error('Synchronous save error:', error);
                }
                resolve();
            });
        }
    }

    // Enhanced auto-save indicator with different types (from memo.html)
    function showAutoSaveIndicator(type = 'auto') {
        if (!autoSaveIndicator) return;
        
        const icon = autoSaveIndicator.querySelector('i');
        const text = autoSaveIndicator.querySelector('span');
        
        if (icon && text) {
            // Change icon and text based on save type
            if (type === 'focus-out') {
                icon.className = 'bi bi-save';
                text.textContent = 'Saved on focus out';
            } else {
                icon.className = 'bi bi-check-circle';
                text.textContent = currentDocumentId ? 'Auto-updated' : 'Auto-saved';
            }
        }
        
        autoSaveIndicator.classList.add('show');
        
        // Hide the indicator after 3 seconds
        setTimeout(() => {
            autoSaveIndicator.classList.remove('show');
        }, 3000);
    }

    // ===== UNDO/REDO FUNCTIONALITY =====
    
    function saveState() {
        const state = {
            content: textarea.value,
            selectionStart: textarea.selectionStart,
            selectionEnd: textarea.selectionEnd
        };
        
        if (undoStack.length === 0 || undoStack[undoStack.length - 1].content !== state.content) {
            undoStack.push(state);
            if (undoStack.length > maxUndoSteps) {
                undoStack.shift();
            }
            redoStack = []; // Clear redo stack on new action
        }
    }

    function saveInitialState() {
        undoStack = [];
        redoStack = [];
        saveState();
    }

    function undo() {
        if (undoStack.length > 1) {
            const currentState = undoStack.pop();
            redoStack.push(currentState);
            
            const previousState = undoStack[undoStack.length - 1];
            textarea.value = previousState.content;
            textarea.setSelectionRange(previousState.selectionStart, previousState.selectionEnd);
            textarea.focus();
        }
    }

    function redo() {
        if (redoStack.length > 0) {
            const state = redoStack.pop();
            undoStack.push(state);
            
            textarea.value = state.content;
            textarea.setSelectionRange(state.selectionStart, state.selectionEnd);
            textarea.focus();
        }
    }

    // ===== NUMBERING AND INDENTATION =====
    
    function getTabSkipCount() {
        const tabSkipSelect = document.getElementById('tabSkipCount');
        return tabSkipSelect ? parseInt(tabSkipSelect.value) : 1; // Default to 1 if not found
    }

    // Check if numbering is enabled
    function isNumberingEnabled() {
        const numberingCheckbox = document.getElementById('enableNumbering');
        return numberingCheckbox ? numberingCheckbox.checked : true; // Default to true if not found
    }

    // Calculate byte length for 2-byte characters
    function getByteLength(str) {
        let length = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charAt(i);
            if (char.match(/[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/)) {
                length += 2;
            } else {
                length += 1;
            }
        }
        return length;
    }

    // Find the nearest number in format (n)
    function findNearestNumber(lines, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            const match = lines[i].match(/\((\d+)\)/);
            if (match) {
                return parseInt(match[1]);
            }
        }
        return 0; // Default to 0 if no number is found
    }

    // Find the nearest Roman numeral in format (i), (ii), etc.
    function findNearestRomanNumeral(lines, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            // Updated regex to match proper Roman numerals
            const match = lines[i].match(/\((i{1,3}|iv|v|vi{0,3}|ix|x{1,3}|xl|l|lx{0,3}|xc|c{1,3}|cd|d|dc{0,3}|cm|m{1,3})\)/i);
            if (match) {
                const romanStr = match[1].toLowerCase();
                
                // Convert Roman numeral back to number
                const romanToNumber = {
                    'i': 1, 'ii': 2, 'iii': 3, 'iv': 4, 'v': 5, 'vi': 6, 'vii': 7, 'viii': 8, 'ix': 9, 'x': 10,
                    'xi': 11, 'xii': 12, 'xiii': 13, 'xiv': 14, 'xv': 15, 'xvi': 16, 'xvii': 17, 'xviii': 18, 'xix': 19, 'xx': 20,
                    'xxi': 21, 'xxii': 22, 'xxiii': 23, 'xxiv': 24, 'xxv': 25, 'xxvi': 26, 'xxvii': 27, 'xxviii': 28, 'xxix': 29, 'xxx': 30
                };
                
                if (romanToNumber[romanStr]) {
                    return romanToNumber[romanStr];
                }
                
                // For complex Roman numerals > 30, use algorithmic conversion
                return convertRomanToNumber(romanStr);
            }
        }
        return 0;
    }

    function convertRomanToNumber(roman) {
        const romanValues = {
            'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000
        };
        
        let result = 0;
        let prevValue = 0;
        
        for (let i = roman.length - 1; i >= 0; i--) {
            const currentValue = romanValues[roman[i].toLowerCase()];
            
            if (currentValue < prevValue) {
                result -= currentValue;
            } else {
                result += currentValue;
            }
            
            prevValue = currentValue;
        }
        
        return result;
    }
    // Check if there's a line with <条件> or ＜条件＞ above the current line
    function hasConditionAbove(lines, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            if (lines[i].includes('<条件>') || lines[i].includes('＜条件＞')) {
                return true;
            }
            // Stop searching if we encounter a new section (level 1 numbering)
            if (lines[i].match(/^\((\d+)\)/)) {
                break;
            }
        }
        return false;
    }

    // Generate Roman numeral
    function generateRomanNumeral(count) {
        const romanNumerals = [
            '', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x',
            'xi', 'xii', 'xiii', 'xiv', 'xv', 'xvi', 'xvii', 'xviii', 'xix', 'xx',
            'xxi', 'xxii', 'xxiii', 'xxiv', 'xxv', 'xxvi', 'xxvii', 'xxviii', 'xxix', 'xxx'
        ];
        
        if (count <= 30) {
            return romanNumerals[count];
        }
        
        // For numbers > 30, use algorithmic approach
        const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
        const symbols = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'];
        
        let result = '';
        let num = count;
        
        for (let i = 0; i < values.length; i++) {
            while (num >= values[i]) {
                result += symbols[i];
                num -= values[i];
            }
        }
        
        return result;
    }

    // Generate number based on indentation level and previous numbers
    function generateNumber(lines, currentIndex, level) {
        if (level === 1) {
            const lastNumber = findNearestNumber(lines, currentIndex);
            return `(${lastNumber + 1})`;
        } else if (level === 2) {
            return '(a)';
        } else if (level >= 3) {
            return `(a${'-1'.repeat(level - 2)})`;
        }
        return ''; // Return empty string for level 0 (no indent)
    }

    // Find the end of the prefix (indent + number + space)
    function findPrefixEnd(line) {
        let i = 0;
        // Skip full-width spaces
        while (i < line.length && line[i] === '　') {
            i++;
        }
        // Skip number in parentheses, e.g., (1), (a), (a-1-1)
        if (i < line.length && line[i] === '(') {
            while (i < line.length && line[i] !== ')') {
                i++;
            }
            if (i < line.length) i++; // Include closing parenthesis
        }
        // Skip trailing space
        if (i < line.length && line[i] === ' ') {
            i++;
        }
        return i;
    }

    // ===== EVENT LISTENERS (UPDATED) =====
    
    // Content and title input events - XÓA debouncing auto-save
    if (textarea) {
        textarea.addEventListener('input', function() {
            // Chỉ save state for undo
            clearTimeout(inputTimer);
            inputTimer = setTimeout(() => {
                saveState();
            }, 500);
            // Không gọi auto-save ngay, để timer interval xử lý
        });

        textarea.addEventListener('blur', function() {
            performAutoSaveOnFocusOut();
        });

        // Keyboard shortcuts and special handling
        textarea.addEventListener('keydown', function(e) {
            // Undo/Redo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
                return;
            }
            
            if (e.ctrlKey && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
                return;
            }

            // Manual save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                performAutoSave(); // Sửa thành performAutoSave thay vì performAutoSave('manual')
                return;
            }
            

            // Tab handling code unchanged...
            if (e.key === 'Tab') {
                e.preventDefault();
                
                // Save state before making changes
                saveState();

                const start = textarea.selectionStart;
                const value = textarea.value;
                const lines = value.substring(0, start).split('\n');
                const currentLineIndex = lines.length - 1;
                const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
                const currentLine = value.substring(currentLineStart);
                const prefixEnd = currentLineStart + findPrefixEnd(currentLine);
                const restOfLine = value.substring(prefixEnd);

                // Reset tab count if on a new line
                if (currentLineIndex !== lastLineIndex) {
                    currentTabCount = 0;
                    // Only calculate indent level if numbering is enabled
                    if (isNumberingEnabled()) {
                        // Calculate current indent level from existing prefix
                        const currentLineContent = value.substring(currentLineStart, value.indexOf('\n', currentLineStart) >= 0 ? value.indexOf('\n', currentLineStart) : value.length);
                        
                        // Initialize indentCount for counting spaces
                        let indentCount = 0;
                        for (let i = 0; i < currentLineContent.length && currentLineContent[i] === '　'; i++) {
                            indentCount++;
                        }

                        // Determine current level based on prefix
                        if (currentLineContent.match(/^\s*$/)) {
                            currentLineIndent = 0; // Empty line
                        } else if (currentLineContent.match(/^[^(]*$/)) {
                            currentLineIndent = 0; // No parentheses
                        } else if (currentLineContent.match(/^\((\d+)\)/)) {
                            currentLineIndent = 1; // Format (n)
                        } else if (currentLineContent.match(/^　*\([a-z]\)(?!\-)/) || currentLineContent.match(/^　*\((i+)\)/)) {
                            currentLineIndent = 2; // Format (a) or (i)
                        } else if (currentLineContent.match(/^　*\([a-z](-\d+)+\)/)) {
                            const matches = currentLineContent.match(/^　*\([a-z]((-\d+)*)\)/);
                            if (matches && matches[1]) {
                                const dashCount = (matches[1].match(/-/g) || []).length;
                                currentLineIndent = 2 + dashCount;
                            } else {
                                currentLineIndent = 2;
                            }
                        } else {
                            currentLineIndent = indentCount; // Use space count for non-numbered lines
                        }

                        // Initialize currentTabCount based on indentCount and currentLineIndent
                        const tabSkipCount = getTabSkipCount();
                        currentTabCount = currentLineIndent > 0 ? tabSkipCount + currentLineIndent - 1 : indentCount;
                    } else {
                        // If numbering is disabled, reset indent to 0
                        currentLineIndent = 0;
                        // Count spaces for non-numbered lines
                        const currentLineContent = value.substring(currentLineStart, value.indexOf('\n', currentLineStart) >= 0 ? value.indexOf('\n', currentLineStart) : value.length);
                        let indentCount = 0;
                        for (let i = 0; i < currentLineContent.length && currentLineContent[i] === '　'; i++) {
                            indentCount++;
                        }
                        currentTabCount = indentCount;
                    }
                    lastLineIndex = currentLineIndex;
                }

                const tabSkipCount = getTabSkipCount();
                const numberingEnabled = isNumberingEnabled();

                // Handle Shift+Tab (decrease indent)
                if (e.shiftKey) {
                    // Decrease tab count
                    currentTabCount = Math.max(0, currentTabCount - 1);
                    
                    if (numberingEnabled) {
                        // Decrease indent level if numbering is enabled
                        currentLineIndent = Math.max(0, currentLineIndent - 1);
                        
                        // Get content after the numbering prefix
                        const currentLineContent = value.substring(currentLineStart);
                        const lineEnd = currentLineContent.indexOf('\n');
                        const fullLine = lineEnd >= 0 ? currentLineContent.substring(0, lineEnd) : currentLineContent;
                        const prefixEndLocal = findPrefixEnd(fullLine);
                        const contentAfterPrefix = fullLine.substring(prefixEndLocal);
                        
                        if (currentLineIndent === 0) {
                            // Remove all numbering, keep only spaces up to tabSkipCount or currentTabCount
                            const spacesToKeep = Math.min(tabSkipCount, currentTabCount);
                            const newLinePrefix = '　'.repeat(spacesToKeep);
                            const newValue = value.substring(0, currentLineStart) + newLinePrefix + contentAfterPrefix + value.substring(currentLineStart + fullLine.length);
                            textarea.value = newValue;
                            textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
                        } else {
                            // Apply numbering for the new indent level
                            applyNumberingLogicForShiftTab(contentAfterPrefix);
                        }
                    } else {
                        // If numbering is disabled, just remove one space if available
                        let existingSpaces = 0;
                        for (let i = 0; i < currentLine.length && currentLine[i] === '　'; i++) {
                            existingSpaces++;
                        }
                        if (existingSpaces > 0) {
                            const newLinePrefix = '　'.repeat(existingSpaces - 1);
                            const newValue = value.substring(0, currentLineStart) + newLinePrefix + restOfLine;
                            textarea.value = newValue;
                            textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
                        }
                    }
                } else {
                    // Handle regular Tab (increase indent)
                    currentTabCount++;
                    
                    if (!numberingEnabled) {
                        // If numbering is disabled, just add one full-width space
                        const newValue = value.substring(0, start) + '　' + value.substring(start);
                        textarea.value = newValue;
                        textarea.selectionStart = textarea.selectionEnd = start + 1;
                        lastLineIndex = currentLineIndex;
                        return;
                    }
                    
                    // Numbering is enabled - check if we should just add spacing without numbering
                    if (currentTabCount <= tabSkipCount) {
                        // Just add full-width space (2-byte character)
                        const newValue = value.substring(0, start) + '　' + value.substring(start);
                        textarea.value = newValue;
                        textarea.selectionStart = textarea.selectionEnd = start + 1;
                        lastLineIndex = currentLineIndex;
                        return;
                    }
                    
                    // We're past the skip count and numbering is enabled, so increase indent level and apply numbering
                    currentLineIndent++;
                    applyNumberingLogic();
                }
                
                function applyNumberingLogicForShiftTab(contentAfterPrefix) {
                    let number = '';
                    if (currentLineIndent > 0) {
                        if (currentLineIndent === 1) {
                            const lastNumber = findNearestNumber(textarea.value.split('\n'), currentLineIndex);
                            number = `(${lastNumber + 1})`;
                        } else if (currentLineIndent === 2) {
                            if (hasConditionAbove(textarea.value.split('\n'), currentLineIndex)) {
                                const lastRoman = findNearestRomanNumeral(textarea.value.split('\n'), currentLineIndex);
                                number = `(${generateRomanNumeral(lastRoman + 1)})`;
                            } else {
                                let lastLetter = '';
                                for (let i = currentLineIndex - 1; i >= 0; i--) {
                                    const line = textarea.value.split('\n')[i];
                                    if (line.match(/^\((\d+)\)/)) {
                                        break;
                                    }
                                    // THÊM LOGIC ROMAN NUMERAL Ở ĐÂY
                                    const romanMatch = line.match(/^　*\((i{1,3}|iv|v|vi{0,3}|ix|x{1,3}|xl|l|lx{0,3}|xc|c{1,3}|cd|d|dc{0,3}|cm|m{1,3})\)/i);
                                    if (romanMatch) {
                                        const lastRoman = convertRomanToNumber(romanMatch[1]);
                                        number = `(${generateRomanNumeral(lastRoman + 1)})`;
                                        break;
                                    }
                                    
                                    const match = line.match(/^　*\(([a-z])\)(?!\-)/);
                                    if (match) {
                                        lastLetter = match[1];
                                        break;
                                    }
                                }
                            
                                if (!number) {
                                    number = lastLetter ? `(${String.fromCharCode(lastLetter.charCodeAt(0) + 1)})` : '(a)';
                                }
                            }
                        } else if (currentLineIndent >= 3) {
                            let parentPattern = '';
                            let parentLevel = currentLineIndent - 1;
                            
                            for (let i = currentLineIndex - 1; i >= 0; i--) {
                                const line = textarea.value.split('\n')[i];
                                if (line.match(/^\((\d+)\)/)) {
                                    break;
                                }
                                if (parentLevel === 2) {
                                    const letterMatch = line.match(/^　*\(([a-z])\)(?!\-)/);
                                    const romanMatch = line.match(/^　*\((i+)\)/);
                                    if (letterMatch) {
                                        parentPattern = letterMatch[1];
                                        break;
                                    } else if (romanMatch) {
                                        const romanCount = romanMatch[1].length;
                                        parentPattern = String.fromCharCode('a'.charCodeAt(0) + romanCount - 1);
                                        break;
                                    }
                                } else {
                                    const regex = new RegExp(`^　*\\(([a-z](-\\d+){${parentLevel - 2}})\\)(?!\\-)`);
                                    const match = line.match(regex);
                                    if (match) {
                                        parentPattern = match[1];
                                        break;
                                    }
                                }
                            }
                            
                            if (!parentPattern) {
                                parentPattern = currentLineIndent === 3 ? 'a' : 'a' + '-1'.repeat(currentLineIndent - 3);
                            }
                            
                            let lastNumber = 0;
                            const searchPattern = `^　*\\(${parentPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}-(\\d+)\\)`;
                            const currentRegex = new RegExp(searchPattern);
                            
                            for (let i = currentLineIndex - 1; i >= 0; i--) {
                                const line = textarea.value.split('\n')[i];
                                if (line.match(/^\((\d+)\)/)) {
                                    break;
                                }
                                const match = line.match(currentRegex);
                                if (match) {
                                    lastNumber = parseInt(match[1]);
                                    break;
                                }
                            }
                            
                            number = `(${parentPattern}-${lastNumber + 1})`;
                        }

                        // Calculate spaces needed for new indent level
                        const totalSpaces = tabSkipCount + Math.max(0, currentLineIndent - 1);
                        const indent = '　'.repeat(totalSpaces);
                        const newLinePrefix = indent + number + ' ';

                        // Replace the current line
                        const lineEnd = textarea.value.substring(currentLineStart).indexOf('\n');
                        const newValue = textarea.value.substring(0, currentLineStart) + 
                                    newLinePrefix + contentAfterPrefix + 
                                    textarea.value.substring(currentLineStart + (lineEnd >= 0 ? lineEnd : textarea.value.length - currentLineStart));
                        textarea.value = newValue;

                        // Update cursor position
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
                    }
                }

                function applyNumberingLogic() {
                    let number = '';
                    if (currentLineIndent > 0) {
                        if (currentLineIndent === 1) {
                            const lastNumber = findNearestNumber(value.split('\n'), currentLineIndex);
                            number = `(${lastNumber + 1})`;
                        } else if (currentLineIndent === 2) {
                            if (hasConditionAbove(textarea.value.split('\n'), currentLineIndex)) {
                                const lastRoman = findNearestRomanNumeral(textarea.value.split('\n'), currentLineIndex);
                                number = `(${generateRomanNumeral(lastRoman + 1)})`;
                            } else {
                                let lastLetter = '';
                                for (let i = currentLineIndex - 1; i >= 0; i--) {
                                    const line = textarea.value.split('\n')[i];
                                    if (line.match(/^\((\d+)\)/)) {
                                        break;
                                    }
                                    // THÊM LOGIC ROMAN NUMERAL Ở ĐÂY
                                    const romanMatch = line.match(/^　*\((i{1,3}|iv|v|vi{0,3}|ix|x{1,3}|xl|l|lx{0,3}|xc|c{1,3}|cd|d|dc{0,3}|cm|m{1,3})\)/i);
                                    if (romanMatch) {
                                        const lastRoman = convertRomanToNumber(romanMatch[1]);
                                        number = `(${generateRomanNumeral(lastRoman + 1)})`;
                                        break;
                                    }
                                    
                                    const match = line.match(/^　*\(([a-z])\)(?!\-)/);
                                    if (match) {
                                        lastLetter = match[1];
                                        break;
                                    }
                                }
                                if (!number) {
                                    number = lastLetter ? `(${String.fromCharCode(lastLetter.charCodeAt(0) + 1)})` : '(a)';
                                }
                            }
                        } else if (currentLineIndent >= 3) {
                            let parentPattern = '';
                            let parentLevel = currentLineIndent - 1;
                            const lines = value.split('\n');

                            for (let i = currentLineIndex - 1; i >= 0; i--) {
                                const line = lines[i];
                                if (/^[\s\u3000]{0,5}\(\d+\)/.test(line)) {
                                    break;
                                }
                                if (parentLevel === 2) {
                                    const letterMatch = line.match(/^[\s\u3000]{0,5}\(([a-z])\)(?!\-)/);
                                    const romanMatch = line.match(/^[\s\u3000]{0,5}\((i+)\)/);
                                    if (letterMatch) {
                                        parentPattern = letterMatch[1];
                                        break;
                                    } else if (romanMatch) {
                                        const romanCount = romanMatch[1].length;
                                        parentPattern = String.fromCharCode('a'.charCodeAt(0) + romanCount - 1);
                                        break;
                                    }
                                } else {
                                    const regex = new RegExp(`^[\\s\\u3000]{0,5}\\(([a-z](-\\d+){${parentLevel - 2}})\\)(?!\\-)`);
                                    const match = line.match(regex);
                                    if (match) {
                                        parentPattern = match[1];
                                        break;
                                    }
                                }
                            }

                            if (!parentPattern) {
                                parentPattern = currentLineIndent === 3 ? 'a' : 'a' + '-1'.repeat(currentLineIndent - 3);
                            }

                            let lastNumber = 0;
                            const searchPattern = `^[\\s\\u3000]{0,5}\\(${parentPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}-(\\d+)\\)`;
                            const currentRegex = new RegExp(searchPattern);

                            for (let i = currentLineIndex - 1; i >= 0; i--) {
                                const line = lines[i];
                                if (/^[\s\u3000]{0,5}\(\d+\)/.test(line)) {
                                    break;
                                }
                                const match = line.match(currentRegex);
                                if (match) {
                                    lastNumber = parseInt(match[1]);
                                    break;
                                }
                            }

                            number = `(${parentPattern}-${lastNumber + 1})`;
                        }

                        // Calculate total spaces needed
                        const totalSpaces = tabSkipCount + Math.max(0, currentLineIndent - 1);
                        const indent = '　'.repeat(totalSpaces);
                        const newLinePrefix = indent + number + ' ';

                        // Replace the current line's prefix
                        const newValue = value.substring(0, currentLineStart) + newLinePrefix + restOfLine;
                        textarea.value = newValue;

                        // Update cursor position
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
                    } else {
                        // currentLineIndent is 0, keep only spaces from skip count
                        const spacesToKeep = Math.min(tabSkipCount, currentTabCount);
                        const newLinePrefix = '　'.repeat(spacesToKeep);
                        const newValue = value.substring(0, currentLineStart) + newLinePrefix + restOfLine;
                        textarea.value = newValue;
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
                    }
                }

                // Update last line index
                lastLineIndex = currentLineIndex;

            } else {
                // Save state for other significant changes
                if (e.key === 'Enter' || e.key === 'Backspace' || e.key === 'Delete') {
                    saveState();
                }
                
                // Reset indent and tab count on Enter
                if (e.key === 'Enter') {
                    currentLineIndent = 0;
                    lastLineIndex = -1;
                    currentTabCount = 0;
                }

                // Reset indent and tab count when deleting back to beginning of line
                if (e.key === 'Backspace') {
                    setTimeout(() => {
                        const start = textarea.selectionStart;
                        const value = textarea.value;
                        const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
                        
                        // If cursor is at the beginning of a line, reset state
                        if (start === currentLineStart) {
                            currentLineIndent = 0;
                            lastLineIndex = -1;
                            currentTabCount = 0;
                        }
                    }, 10);
                }

                if (e.key === 'Backspace' || e.key === 'Delete') {
                    setTimeout(() => {
                        const start = textarea.selectionStart;
                        const value = textarea.value;
                        const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
                        
                        // If cursor is at the beginning of a line, reset state
                        if (start === currentLineStart) {
                            currentLineIndent = 0;
                            lastLineIndex = -1;
                            currentTabCount = 0;
                        }
                    }, 10);
                }

                // Auto line break at 140 bytes
                if (e.key !== 'Enter' && e.key !== 'Backspace' && e.key !== 'Delete') {
                    setTimeout(() => {
                        const start = textarea.selectionStart;
                        const value = textarea.value;
                        const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
                        const currentLine = value.substring(currentLineStart, start);

                        if (getByteLength(currentLine) > 140) {
                            saveState(); // Save state before auto line break
                            
                            let breakPoint = currentLine.length;
                            for (let i = currentLine.length - 1; i >= 0; i--) {
                                if (getByteLength(currentLine.substring(0, i)) <= 140) {
                                    if (currentLine[i] === ' ') {
                                        breakPoint = i;
                                        break;
                                    }
                                    if (i === 0) breakPoint = i;
                                }
                            }

                            const newValue = value.substring(0, currentLineStart + breakPoint) + 
                                            '\n' + 
                                            value.substring(currentLineStart + breakPoint);
                            textarea.value = newValue;
                            textarea.selectionStart = textarea.selectionEnd = currentLineStart + breakPoint + 1;
                        }
                    }, 10);
                }
            }
        });
    }

    if (titleInput) {
        titleInput.addEventListener('input', function() {
            // Không gọi auto-save ngay, để timer interval xử lý
        });

        titleInput.addEventListener('blur', function() {
            performAutoSaveOnFocusOut();
        });
    }

    // === NEW: All focus out event listeners from memo.html ===
    
    // Save when user clicks outside the form area
    document.addEventListener('click', function(e) {
        const formArea = document.querySelector('#editorForm');
        const headerArea = document.querySelector('.d-flex.justify-content-between.align-items-center.mb-4');
        
        if (formArea && !formArea.contains(e.target) && 
            (!headerArea || !headerArea.contains(e.target))) {
            performAutoSaveOnFocusOut();
        }
    });
    
    // Save when user navigates away or closes tab
    window.addEventListener('beforeunload', function(e) {
        if (autoSaveTimer) {
            clearInterval(autoSaveTimer);
        }
        if (contentChangeTimer) clearTimeout(contentChangeTimer);
        if (inputTimer) clearTimeout(inputTimer);
        
        // Perform final save before leaving
        performAutoSaveOnFocusOut(true); // synchronous save
    });
    
    // Save when page loses focus (user switches tabs/apps)
    window.addEventListener('blur', function() {
        performAutoSaveOnFocusOut();
    });
    
    // Save when page gains focus back (in case changes were made)
    window.addEventListener('focus', function() {
        // Small delay to ensure any programmatic changes are completed
        setTimeout(() => {
            performAutoSaveOnFocusOut();
        }, 100);
    });
    
    // Save when user presses ESC key (common way to "exit" editing)
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            performAutoSaveOnFocusOut();
        }
    });
    
    // === Navigation-based auto-save from memo.html ===
    
    // Handle link clicks that might navigate away
    document.addEventListener('click', function(e) {
        const link = e.target.closest('a');
        if (link && link.href && !link.href.startsWith('javascript:') && !link.href.includes('#')) {
            // Small delay to allow save before navigation
            e.preventDefault();
            performAutoSaveOnFocusOut(true).then(() => {
                window.location.href = link.href;
            });
        }
    });

    // Form submission
    if (form) {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const title = titleInput.value.trim();
            const content = textarea.value.trim();
            
            if (!title) {
                alert('Title is required');
                titleInput.focus();
                return;
            }
            
            if (currentDocumentId) {
                updateDocument(currentDocumentId, title, content);
            } else {
                createDocument(title, content);
            }
        });
    }

    // Numbering checkbox change
    const numberingCheckbox = document.getElementById('enableNumbering');
    if (numberingCheckbox) {
        numberingCheckbox.addEventListener('change', function() {
            // Reset state when toggling numbering
            currentLineIndent = 0;
            lastLineIndex = -1;
            currentTabCount = 0;
        });
    }

    // ===== DOCUMENT OPERATIONS =====
    
    function createDocument(title, content) {
        return fetch('/api/editor_documents', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ title, content })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                console.log('Document created successfully:', data.id);
                window.location.href = '/editor_list';
            } else {
                throw new Error(data.error || 'Failed to create document');
            }
            return data;
        })
        .catch(error => {
            console.error('Create document error:', error);
            alert('Error saving document: ' + error.message);
            throw error;
        });
    }

    function updateDocument(documentId, title, content) {
        return fetch(`/api/editor_documents/${documentId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ title, content })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                console.log('Document updated successfully');
                window.location.href = '/editor_list';
            } else {
                throw new Error(data.error || 'Failed to update document');
            }
            return data;
        })
        .catch(error => {
            console.error('Update document error:', error);
            alert('Error updating document: ' + error.message);
            throw error;
        });
    }

    // ===== INITIALIZATION =====
    
    function initializeEditor() {
        console.log('Initializing editor...');
        
        initializeDocumentId();
        initializeAutoSave(); // Sửa thành initializeAutoSave()
        saveInitialState();
        
        // Load document if ID exists in URL
        const urlParams = new URLSearchParams(window.location.search);
        const documentId = urlParams.get('id');
        if (documentId) {
            loadDocument(documentId);
        }
        
        console.log('Editor initialized with:', {
            documentId: currentDocumentId,
            hasContent: !!textarea.value,
            hasTitle: !!titleInput.value
        });
    }

    // Start the editor
    initializeEditor();

    // Global functions for external access
    window.editorAPI = {
        save: performAutoSave, // Sửa thành performAutoSave
        undo: undo,
        redo: redo,
        getCurrentDocumentId: () => currentDocumentId,
        getAutoSaveStatus: () => ({ isAutoSaving, lastSavedTitle, lastSavedContent })
    };

    function updateEditorActiveState() {
        const title = titleInput.value.trim();
        textarea.disabled = !title;
        if (!title) {
            textarea.classList.add('bg-light');
        } else {
            textarea.classList.remove('bg-light');
        }
    }

    updateEditorActiveState();
    titleInput.addEventListener('input', updateEditorActiveState);
});

</script>

{% endblock %}