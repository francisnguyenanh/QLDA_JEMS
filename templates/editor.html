{% extends "layout.html" %}
{% block navbar_content %}
<ul class="navbar-nav me-auto">
    <li class="nav-item">
        <a class="nav-link" href="/dashboard">Dashboard</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" href="/editor_list">Documents list</a>
    </li>
    <li class="nav-item">
        <a class="nav-link active" href="/editor">Editor</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" href="/memo_list">Memo list</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" href="/memo">Memo</a>
    </li>
</ul>
<div class="d-flex">
    <a href="{{ url_for('logout') }}" class="btn btn-danger btn-sm">Logout</a>
</div>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <!-- Header với buttons -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h2 id="pageTitle">{{ 'Edit Document' if document else 'New Document' }}</h2>
        <div class="btn-group">
            <button type="button" class="btn btn-primary" onclick="saveDocument()">Save</button>
            <a href="{{ url_for('editor_list') }}" class="btn btn-secondary">Cancel</a>
        </div>
    </div>
    
    <form id="editorForm">
        <div class="mb-3">
            <label for="title" class="form-label">Title</label>
            <input type="text" class="form-control" id="title" name="title" 
                   value="{{ document.title if document else '' }}" required>
        </div>
        
        <!-- Content A và Tab Configuration nằm ngang hàng -->
        <div class="row mb-3">
            <div class="col-12"> <!-- Changed from col-md-8 -->               
                <!-- Checkbox và Select trên cùng 1 hàng -->
                <div class="d-flex align-items-center gap-3 mb-2">
                    <div class="form-check">
                        <input type="checkbox" id="enableNumbering" class="form-check-input" checked>
                        <label for="enableNumbering" class="form-check-label" style="font-size: 12px;">Enable auto numbering</label>
                    </div>
                    <div class="d-flex align-items-center gap-2">
                        <label for="tabSkipCount" class="form-label mb-0" style="font-size: 12px; white-space: nowrap;">Tab skip count:</label>
                        <select id="tabSkipCount" class="form-select form-select-sm" style="width: 200px;">
                            <option value="0">0 (immediate numbering)</option>
                            <option value="1" selected>1 (skip first tab)</option>
                            <option value="2">2 (skip first 2 tabs)</option>
                            <option value="3">3 (skip first 3 tabs)</option>
                            <option value="3">4 (skip first 4 tabs)</option>
                            <option value="3">5 (skip first 5 tabs)</option>
                        </select>
                    </div>
                </div>
                
                <textarea class="form-control" id="editorContent" name="content" 
                rows="20" style="font-family: monospace; font-size: 14px;" required>{{ document.content if document else '' }}</textarea>
            </div>
        </div>
    </form>
</div>

<style>
#editorContent {
    line-height: 1.5;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* Sticky header cho dễ truy cập */
.container-fluid .d-flex:first-child {
    position: sticky;
    top: 0;
    background: white;
    z-index: 100;
    padding: 10px 0;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Responsive cho mobile */
@media (max-width: 768px) {
    .row .col-md-2, .row .col-md-8 {
        margin-bottom: 15px;
    }
    
    /* Trên mobile, Title và Settings stack vertically, Content full width */
    .col-md-2:first-child {
        order: 1;
    }
    .col-md-8 {
        order: 3;
    }
    .col-md-2:last-child {
        order: 2;
    }
}
@media (max-width: 768px) {
    /* Remove the old col-md-2, col-md-8 rules and replace with: */
    .col-12 {
        margin-bottom: 15px;
    }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const textarea = document.getElementById('editorContent');
    const form = document.getElementById('editorForm');
    let currentLineIndent = 0;
    let lastLineIndex = -1;
    let currentTabCount = 0; // Track current tab count for the line

    // Undo/Redo functionality
    let undoStack = [];
    let redoStack = [];
    const maxUndoSteps = 50; // Giới hạn số bước undo để tránh tốn bộ nhớ

    // Save state for undo
    function saveState() {
        const state = {
            content: textarea.value,
            selectionStart: textarea.selectionStart,
            selectionEnd: textarea.selectionEnd
        };
        
        // Kiểm tra xem state mới có khác state cuối cùng không
        if (undoStack.length === 0 || undoStack[undoStack.length - 1].content !== state.content) {
            undoStack.push(state);
            // Giới hạn số lượng undo steps
            if (undoStack.length > maxUndoSteps) {
                undoStack.shift();
            }
            // Clear redo stack khi có action mới
            redoStack = [];
        }
    }

    // Undo function
    function undo() {
        if (undoStack.length > 1) { // Cần ít nhất 2 states để undo
            // Di chuyển state hiện tại sang redo stack
            const currentState = undoStack.pop();
            redoStack.push(currentState);
            
            // Lấy state trước đó
            const previousState = undoStack[undoStack.length - 1];
            textarea.value = previousState.content;
            textarea.selectionStart = previousState.selectionStart;
            textarea.selectionEnd = previousState.selectionEnd;
            
            // Reset editor state
            currentLineIndent = 0;
            lastLineIndex = -1;
            currentTabCount = 0;
        }
    }

    // Redo function
    function redo() {
        if (redoStack.length > 0) {
            const nextState = redoStack.pop();
            undoStack.push(nextState);
            
            textarea.value = nextState.content;
            textarea.selectionStart = nextState.selectionStart;
            textarea.selectionEnd = nextState.selectionEnd;
            
            // Reset editor state
            currentLineIndent = 0;
            lastLineIndex = -1;
            currentTabCount = 0;
        }
    }

    // Save initial state
    saveState();

    // Get tab skip count from layout setting
    function getTabSkipCount() {
        const tabSkipSelect = document.getElementById('tabSkipCount');
        return tabSkipSelect ? parseInt(tabSkipSelect.value) : 1; // Default to 1 if not found
    }

    // Check if numbering is enabled
    function isNumberingEnabled() {
        const numberingCheckbox = document.getElementById('enableNumbering');
        return numberingCheckbox ? numberingCheckbox.checked : true; // Default to true if not found
    }

    // Calculate byte length for 2-byte characters
    function getByteLength(str) {
        let length = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charAt(i);
            if (char.match(/[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/)) {
                length += 2;
            } else {
                length += 1;
            }
        }
        return length;
    }

    // Find the nearest number in format (n)
    function findNearestNumber(lines, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            const match = lines[i].match(/\((\d+)\)/);
            if (match) {
                return parseInt(match[1]);
            }
        }
        return 0; // Default to 0 if no number is found
    }

    // Find the nearest Roman numeral in format (i), (ii), etc.
    function findNearestRomanNumeral(lines, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            const match = lines[i].match(/\((i+)\)/);
            if (match) {
                return match[1].length; // Return the count of 'i' characters
            }
        }
        return 0; // Default to 0 if no Roman numeral is found
    }

    // Check if there's a line with <条件> or ＜条件＞ above the current line
    function hasConditionAbove(lines, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            if (lines[i].includes('<条件>') || lines[i].includes('＜条件＞')) {
                return true;
            }
            // Stop searching if we encounter a new section (level 1 numbering)
            if (lines[i].match(/^\((\d+)\)/)) {
                break;
            }
        }
        return false;
    }

    // Generate Roman numeral
    function generateRomanNumeral(count) {
        return 'i'.repeat(count);
    }

    // Generate number based on indentation level and previous numbers
    function generateNumber(lines, currentIndex, level) {
        if (level === 1) {
            const lastNumber = findNearestNumber(lines, currentIndex);
            return `(${lastNumber + 1})`;
        } else if (level === 2) {
            return '(a)';
        } else if (level >= 3) {
            return `(a${'-1'.repeat(level - 2)})`;
        }
        return ''; // Return empty string for level 0 (no indent)
    }

    // Find the end of the prefix (indent + number + space)
    function findPrefixEnd(line) {
        let i = 0;
        // Skip full-width spaces
        while (i < line.length && line[i] === '　') {
            i++;
        }
        // Skip number in parentheses, e.g., (1), (a), (a-1-1)
        if (i < line.length && line[i] === '(') {
            while (i < line.length && line[i] !== ')') {
                i++;
            }
            if (i < line.length) i++; // Include closing parenthesis
        }
        // Skip trailing space
        if (i < line.length && line[i] === ' ') {
            i++;
        }
        return i;
    }

        textarea.addEventListener('keydown', function(e) {
    // Handle Ctrl+Z (Undo) and Ctrl+Y (Redo)
    if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
        return;
    }
    
    if (e.ctrlKey && e.key === 'y') {
        e.preventDefault();
        redo();
        return;
    }

    if (e.key === 'Tab') {
        e.preventDefault();
        
        // Save state before making changes
        saveState();

        const start = textarea.selectionStart;
        const value = textarea.value;
        const lines = value.substring(0, start).split('\n');
        const currentLineIndex = lines.length - 1;
        const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
        const currentLine = value.substring(currentLineStart);
        const prefixEnd = currentLineStart + findPrefixEnd(currentLine);
        const restOfLine = value.substring(prefixEnd);

        // Reset tab count if on a new line
        if (currentLineIndex !== lastLineIndex) {
            currentTabCount = 0;
            // Only calculate indent level if numbering is enabled
            if (isNumberingEnabled()) {
                // Calculate current indent level from existing prefix
                const currentLineContent = value.substring(currentLineStart, value.indexOf('\n', currentLineStart) >= 0 ? value.indexOf('\n', currentLineStart) : value.length);
                
                // Initialize indentCount for counting spaces
                let indentCount = 0;
                for (let i = 0; i < currentLineContent.length && currentLineContent[i] === '　'; i++) {
                    indentCount++;
                }

                // Determine current level based on prefix
                if (currentLineContent.match(/^\s*$/)) {
                    currentLineIndent = 0; // Empty line
                } else if (currentLineContent.match(/^[^(]*$/)) {
                    currentLineIndent = 0; // No parentheses
                } else if (currentLineContent.match(/^\((\d+)\)/)) {
                    currentLineIndent = 1; // Format (n)
                } else if (currentLineContent.match(/^　*\([a-z]\)(?!\-)/) || currentLineContent.match(/^　*\((i+)\)/)) {
                    currentLineIndent = 2; // Format (a) or (i)
                } else if (currentLineContent.match(/^　*\([a-z](-\d+)+\)/)) {
                    const matches = currentLineContent.match(/^　*\([a-z]((-\d+)*)\)/);
                    if (matches && matches[1]) {
                        const dashCount = (matches[1].match(/-/g) || []).length;
                        currentLineIndent = 2 + dashCount;
                    } else {
                        currentLineIndent = 2;
                    }
                } else {
                    currentLineIndent = indentCount; // Use space count for non-numbered lines
                }

                // Initialize currentTabCount based on indentCount and currentLineIndent
                const tabSkipCount = getTabSkipCount();
                currentTabCount = currentLineIndent > 0 ? tabSkipCount + currentLineIndent - 1 : indentCount;
            } else {
                // If numbering is disabled, reset indent to 0
                currentLineIndent = 0;
                // Count spaces for non-numbered lines
                const currentLineContent = value.substring(currentLineStart, value.indexOf('\n', currentLineStart) >= 0 ? value.indexOf('\n', currentLineStart) : value.length);
                let indentCount = 0;
                for (let i = 0; i < currentLineContent.length && currentLineContent[i] === '　'; i++) {
                    indentCount++;
                }
                currentTabCount = indentCount;
            }
            lastLineIndex = currentLineIndex;
        }

        const tabSkipCount = getTabSkipCount();
        const numberingEnabled = isNumberingEnabled();

        // Handle Shift+Tab (decrease indent)
        if (e.shiftKey) {
            // Decrease tab count
            currentTabCount = Math.max(0, currentTabCount - 1);
            
            if (numberingEnabled) {
                // Decrease indent level if numbering is enabled
                currentLineIndent = Math.max(0, currentLineIndent - 1);
                
                // Get content after the numbering prefix
                const currentLineContent = value.substring(currentLineStart);
                const lineEnd = currentLineContent.indexOf('\n');
                const fullLine = lineEnd >= 0 ? currentLineContent.substring(0, lineEnd) : currentLineContent;
                const prefixEndLocal = findPrefixEnd(fullLine);
                const contentAfterPrefix = fullLine.substring(prefixEndLocal);
                
                if (currentLineIndent === 0) {
                    // Remove all numbering, keep only spaces up to tabSkipCount or currentTabCount
                    const spacesToKeep = Math.min(tabSkipCount, currentTabCount);
                    const newLinePrefix = '　'.repeat(spacesToKeep);
                    const newValue = value.substring(0, currentLineStart) + newLinePrefix + contentAfterPrefix + value.substring(currentLineStart + fullLine.length);
                    textarea.value = newValue;
                    textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
                } else {
                    // Apply numbering for the new indent level
                    applyNumberingLogicForShiftTab(contentAfterPrefix);
                }
            } else {
                // If numbering is disabled, just remove one space if available
                let existingSpaces = 0;
                for (let i = 0; i < currentLine.length && currentLine[i] === '　'; i++) {
                    existingSpaces++;
                }
                if (existingSpaces > 0) {
                    const newLinePrefix = '　'.repeat(existingSpaces - 1);
                    const newValue = value.substring(0, currentLineStart) + newLinePrefix + restOfLine;
                    textarea.value = newValue;
                    textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
                }
            }
        } else {
            // Handle regular Tab (increase indent)
            currentTabCount++;
            
            if (!numberingEnabled) {
                // If numbering is disabled, just add one full-width space
                const newValue = value.substring(0, start) + '　' + value.substring(start);
                textarea.value = newValue;
                textarea.selectionStart = textarea.selectionEnd = start + 1;
                lastLineIndex = currentLineIndex;
                return;
            }
            
            // Numbering is enabled - check if we should just add spacing without numbering
            if (currentTabCount <= tabSkipCount) {
                // Just add full-width space (2-byte character)
                const newValue = value.substring(0, start) + '　' + value.substring(start);
                textarea.value = newValue;
                textarea.selectionStart = textarea.selectionEnd = start + 1;
                lastLineIndex = currentLineIndex;
                return;
            }
            
            // We're past the skip count and numbering is enabled, so increase indent level and apply numbering
            currentLineIndent++;
            applyNumberingLogic();
        }
        
        function applyNumberingLogicForShiftTab(contentAfterPrefix) {
            let number = '';
            if (currentLineIndent > 0) {
                if (currentLineIndent === 1) {
                    const lastNumber = findNearestNumber(textarea.value.split('\n'), currentLineIndex);
                    number = `(${lastNumber + 1})`;
                } else if (currentLineIndent === 2) {
                    if (hasConditionAbove(textarea.value.split('\n'), currentLineIndex)) {
                        const lastRoman = findNearestRomanNumeral(textarea.value.split('\n'), currentLineIndex);
                        number = `(${generateRomanNumeral(lastRoman + 1)})`;
                    } else {
                        let lastLetter = '';
                        for (let i = currentLineIndex - 1; i >= 0; i--) {
                            const line = textarea.value.split('\n')[i];
                            if (line.match(/^\((\d+)\)/)) {
                                break;
                            }
                            const match = line.match(/^　*\(([a-z])\)(?!\-)/);
                            if (match) {
                                lastLetter = match[1];
                                break;
                            }
                        }
                        number = lastLetter ? `(${String.fromCharCode(lastLetter.charCodeAt(0) + 1)})` : '(a)';
                    }
                } else if (currentLineIndent >= 3) {
                    let parentPattern = '';
                    let parentLevel = currentLineIndent - 1;
                    
                    for (let i = currentLineIndex - 1; i >= 0; i--) {
                        const line = textarea.value.split('\n')[i];
                        if (line.match(/^\((\d+)\)/)) {
                            break;
                        }
                        if (parentLevel === 2) {
                            const letterMatch = line.match(/^　*\(([a-z])\)(?!\-)/);
                            const romanMatch = line.match(/^　*\((i+)\)/);
                            if (letterMatch) {
                                parentPattern = letterMatch[1];
                                break;
                            } else if (romanMatch) {
                                const romanCount = romanMatch[1].length;
                                parentPattern = String.fromCharCode('a'.charCodeAt(0) + romanCount - 1);
                                break;
                            }
                        } else {
                            const regex = new RegExp(`^　*\\(([a-z](-\\d+){${parentLevel - 2}})\\)(?!\\-)`);
                            const match = line.match(regex);
                            if (match) {
                                parentPattern = match[1];
                                break;
                            }
                        }
                    }
                    
                    if (!parentPattern) {
                        parentPattern = currentLineIndent === 3 ? 'a' : 'a' + '-1'.repeat(currentLineIndent - 3);
                    }
                    
                    let lastNumber = 0;
                    const searchPattern = `^　*\\(${parentPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}-(\\d+)\\)`;
                    const currentRegex = new RegExp(searchPattern);
                    
                    for (let i = currentLineIndex - 1; i >= 0; i--) {
                        const line = textarea.value.split('\n')[i];
                        if (line.match(/^\((\d+)\)/)) {
                            break;
                        }
                        const match = line.match(currentRegex);
                        if (match) {
                            lastNumber = parseInt(match[1]);
                            break;
                        }
                    }
                    
                    number = `(${parentPattern}-${lastNumber + 1})`;
                }

                // Calculate spaces needed for new indent level
                const totalSpaces = tabSkipCount + Math.max(0, currentLineIndent - 1);
                const indent = '　'.repeat(totalSpaces);
                const newLinePrefix = indent + number + ' ';

                // Replace the current line
                const lineEnd = textarea.value.substring(currentLineStart).indexOf('\n');
                const newValue = textarea.value.substring(0, currentLineStart) + 
                               newLinePrefix + contentAfterPrefix + 
                               textarea.value.substring(currentLineStart + (lineEnd >= 0 ? lineEnd : textarea.value.length - currentLineStart));
                textarea.value = newValue;

                // Update cursor position
                textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
            }
        }

        function applyNumberingLogic() {
            let number = '';
            if (currentLineIndent > 0) {
                if (currentLineIndent === 1) {
                    const lastNumber = findNearestNumber(value.split('\n'), currentLineIndex);
                    number = `(${lastNumber + 1})`;
                } else if (currentLineIndent === 2) {
                    if (hasConditionAbove(value.split('\n'), currentLineIndex)) {
                        const lastRoman = findNearestRomanNumeral(value.split('\n'), currentLineIndex);
                        number = `(${generateRomanNumeral(lastRoman + 1)})`;
                    } else {
                        let lastLetter = '';
                        for (let i = currentLineIndex - 1; i >= 0; i--) {
                            const line = value.split('\n')[i];
                            if (line.match(/^\((\d+)\)/)) {
                                break;
                            }
                            const match = line.match(/^　*\(([a-z])\)(?!\-)/);
                            if (match) {
                                lastLetter = match[1];
                                break;
                            }
                        }
                        number = lastLetter ? `(${String.fromCharCode(lastLetter.charCodeAt(0) + 1)})` : '(a)';
                    }
                } else if (currentLineIndent >= 3) {
                    let parentPattern = '';
                    let parentLevel = currentLineIndent - 1;
                    
                    for (let i = currentLineIndex - 1; i >= 0; i--) {
                        const line = value.split('\n')[i];
                        if (line.match(/^\((\d+)\)/)) {
                            break;
                        }
                        if (parentLevel === 2) {
                            const letterMatch = line.match(/^　*\(([a-z])\)(?!\-)/);
                            const romanMatch = line.match(/^　*\((i+)\)/);
                            if (letterMatch) {
                                parentPattern = letterMatch[1];
                                break;
                            } else if (romanMatch) {
                                const romanCount = romanMatch[1].length;
                                parentPattern = String.fromCharCode('a'.charCodeAt(0) + romanCount - 1);
                                break;
                            }
                        } else {
                            const regex = new RegExp(`^　*\\(([a-z](-\\d+){${parentLevel - 2}})\\)(?!\\-)`);
                            const match = line.match(regex);
                            if (match) {
                                parentPattern = match[1];
                                break;
                            }
                        }
                    }
                    
                    if (!parentPattern) {
                        parentPattern = currentLineIndent === 3 ? 'a' : 'a' + '-1'.repeat(currentLineIndent - 3);
                    }
                    
                    let lastNumber = 0;
                    const searchPattern = `^　*\\(${parentPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}-(\\d+)\\)`;
                    const currentRegex = new RegExp(searchPattern);
                    
                    for (let i = currentLineIndex - 1; i >= 0; i--) {
                        const line = value.split('\n')[i];
                        if (line.match(/^\((\d+)\)/)) {
                            break;
                        }
                        const match = line.match(currentRegex);
                        if (match) {
                            lastNumber = parseInt(match[1]);
                            break;
                        }
                    }
                    
                    number = `(${parentPattern}-${lastNumber + 1})`;
                }

                // Calculate total spaces needed
                const totalSpaces = tabSkipCount + Math.max(0, currentLineIndent - 1);
                const indent = '　'.repeat(totalSpaces);
                const newLinePrefix = indent + number + ' ';

                // Replace the current line's prefix
                const newValue = value.substring(0, currentLineStart) + newLinePrefix + restOfLine;
                textarea.value = newValue;

                // Update cursor position
                textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
            } else {
                // currentLineIndent is 0, keep only spaces from skip count
                const spacesToKeep = Math.min(tabSkipCount, currentTabCount);
                const newLinePrefix = '　'.repeat(spacesToKeep);
                const newValue = value.substring(0, currentLineStart) + newLinePrefix + restOfLine;
                textarea.value = newValue;
                textarea.selectionStart = textarea.selectionEnd = currentLineStart + newLinePrefix.length;
            }
        }

        // Update last line index
        lastLineIndex = currentLineIndex;

    } else {
        // Save state for other significant changes
        if (e.key === 'Enter' || e.key === 'Backspace' || e.key === 'Delete') {
            saveState();
        }
        
        // Reset indent and tab count on Enter
        if (e.key === 'Enter') {
            currentLineIndent = 0;
            lastLineIndex = -1;
            currentTabCount = 0;
        }

        // Reset indent and tab count when deleting back to beginning of line
        if (e.key === 'Backspace') {
            setTimeout(() => {
                const start = textarea.selectionStart;
                const value = textarea.value;
                const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
                
                // If cursor is at the beginning of a line, reset state
                if (start === currentLineStart) {
                    currentLineIndent = 0;
                    lastLineIndex = -1;
                    currentTabCount = 0;
                }
            }, 10);
        }

        if (e.key === 'Backspace' || e.key === 'Delete') {
            setTimeout(() => {
                const start = textarea.selectionStart;
                const value = textarea.value;
                const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
                
                // If cursor is at the beginning of a line, reset state
                if (start === currentLineStart) {
                    currentLineIndent = 0;
                    lastLineIndex = -1;
                    currentTabCount = 0;
                }
            }, 10);
        }

        // Auto line break at 140 bytes
        if (e.key !== 'Enter' && e.key !== 'Backspace' && e.key !== 'Delete') {
            setTimeout(() => {
                const start = textarea.selectionStart;
                const value = textarea.value;
                const currentLineStart = value.lastIndexOf('\n', start - 1) + 1;
                const currentLine = value.substring(currentLineStart, start);

                if (getByteLength(currentLine) > 140) {
                    saveState(); // Save state before auto line break
                    
                    let breakPoint = currentLine.length;
                    for (let i = currentLine.length - 1; i >= 0; i--) {
                        if (getByteLength(currentLine.substring(0, i)) <= 140) {
                            if (currentLine[i] === ' ') {
                                breakPoint = i;
                                break;
                            }
                            if (i === 0) breakPoint = i;
                        }
                    }

                    const newValue = value.substring(0, currentLineStart + breakPoint) + 
                                    '\n' + 
                                    value.substring(currentLineStart + breakPoint);
                    textarea.value = newValue;
                    textarea.selectionStart = textarea.selectionEnd = currentLineStart + breakPoint + 1;
                }
            }, 10);
        }
    }
});

    // Save state on input (for typing)
    let inputTimer;
    textarea.addEventListener('input', function() {
        clearTimeout(inputTimer);
        inputTimer = setTimeout(() => {
            saveState();
        }, 500); // Save state 500ms after user stops typing
    });

    // Add event listener for numbering checkbox change
    const numberingCheckbox = document.getElementById('enableNumbering');
    if (numberingCheckbox) {
        numberingCheckbox.addEventListener('change', function() {
            // Reset state when toggling numbering
            currentLineIndent = 0;
            lastLineIndex = -1;
            currentTabCount = 0;
        });
    }
    // Thay thế form submit handler
    form.addEventListener('submit', function(e) {
        e.preventDefault();
        
        const title = document.getElementById('title').value.trim();
        const content = textarea.value.trim();
        
        if (!title) {
            alert('Title is required');
            return;
        }
        
        // Kiểm tra xem đang edit hay tạo mới
        const urlParams = new URLSearchParams(window.location.search);
        const documentId = urlParams.get('id');
        
        if (documentId) {
            // Update existing document
            updateDocument(documentId, title, content);
        } else {
            // Create new document
            createDocument(title, content);
        }
    });
    
    // Load document nếu có ID trong URL
    const urlParams = new URLSearchParams(window.location.search);
    const documentId = urlParams.get('id');
    if (documentId) {
        loadDocument(documentId);
    }
});

// Hàm save được gọi từ button
function saveDocument() {
    const title = document.getElementById('title').value.trim();
    const content = document.getElementById('editorContent').value.trim();
    
    if (!title) {
        alert('Title is required');
        return;
    }
    
    // Kiểm tra xem đang edit hay tạo mới
    const urlParams = new URLSearchParams(window.location.search);
    const documentId = urlParams.get('id');
    
    if (documentId) {
        // Update existing document
        updateDocument(documentId, title, content);
    } else {
        // Create new document
        createDocument(title, content);
    }
}

// Keyboard shortcut: Ctrl+S để save
document.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveDocument();
    }
});

function createDocument(title, content) {
    fetch('/api/editor_documents', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ title, content })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Document saved successfully!');
            window.location.href = '/editor_list';
        } else {
            alert('Error: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error saving document');
    });
}

function updateDocument(documentId, title, content) {
    fetch(`/api/editor_documents/${documentId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ title, content })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Document updated successfully!');
            window.location.href = '/editor_list';
        } else {
            alert('Error: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error updating document');
    });
}

function loadDocument(documentId) {
    fetch(`/api/editor_documents/${documentId}`)
    .then(response => response.json())
    .then(data => {
        if (data.document) {
            document.getElementById('title').value = data.document.title;
            document.getElementById('editorContent').value = data.document.content;
            document.querySelector('h2').textContent = 'Edit Document';
        } else {
            alert('Error: ' + (data.error || 'Document not found'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error loading document');
    });
}

</script>
{% endblock %}